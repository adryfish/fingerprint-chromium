From c0e36ad1a65d59cd0c6a67f5c4e78e7baf0cc4e2 Mon Sep 17 00:00:00 2001
From: adryfish <adryfish@outlook.com>
Date: Mon, 8 Sep 2025 00:26:54 +0800
Subject: [PATCH 11/16] 012-canvas-get-image-data.patch

---
 .../canvas2d/base_rendering_context_2d.cc     |   9 +-
 .../platform/graphics/image_data_buffer.cc    |   8 +
 .../platform/graphics/static_bitmap_image.cc  | 369 ++++++++++++------
 3 files changed, 263 insertions(+), 123 deletions(-)

diff --git a/third_party/blink/renderer/modules/canvas/canvas2d/base_rendering_context_2d.cc b/third_party/blink/renderer/modules/canvas/canvas2d/base_rendering_context_2d.cc
index 31b605ef28..6ffb01bc3c 100644
--- a/third_party/blink/renderer/modules/canvas/canvas2d/base_rendering_context_2d.cc
+++ b/third_party/blink/renderer/modules/canvas/canvas2d/base_rendering_context_2d.cc
@@ -13,6 +13,7 @@
 
 #include "base/check.h"
 #include "base/check_op.h"
+#include "base/command_line.h"
 #include "base/location.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/memory/weak_ptr.h"
@@ -26,6 +27,7 @@
 #include "cc/paint/paint_canvas.h"
 #include "cc/paint/paint_flags.h"
 #include "cc/paint/paint_image.h"
+#include "components/ungoogled/ungoogled_switches.h"
 #include "components/viz/common/resources/shared_image_format_utils.h"
 #include "third_party/abseil-cpp/absl/cleanup/cleanup.h"
 #include "third_party/blink/public/common/metrics/document_update_reason.h"
@@ -555,7 +557,9 @@ ImageData* BaseRenderingContext2D::getImageDataInternal(
           snapshot->PaintImageForCurrentFrame().GetSkImageInfo().bounds();
       DCHECK(!bounds.intersect(SkIRect::MakeXYWH(sx, sy, sw, sh)));
     }
-    if (read_pixels_successful && RuntimeEnabledFeatures::FingerprintingCanvasImageDataNoiseEnabled()) {
+
+    const base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+    if (read_pixels_successful && command_line->HasSwitch(switches::kFingerprint)) {
       StaticBitmapImage::ShuffleSubchannelColorData(image_data_pixmap.addr(), image_data_pixmap.info(), sx, sy);
     }
   }
@@ -1261,7 +1265,8 @@ TextMetrics* BaseRenderingContext2D::measureText(const String& text) {
           : nullptr);
 
   // Scale text metrics if enabled
-  if (RuntimeEnabledFeatures::FingerprintingCanvasMeasureTextNoiseEnabled()) {
+  const base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(switches::kFingerprint)) {
     if (HostAsOffscreenCanvas()) {
       if (auto* window = DynamicTo<LocalDOMWindow>(GetTopExecutionContext())) {
         if (window->GetFrame() && window->GetFrame()->GetDocument())
diff --git a/third_party/blink/renderer/platform/graphics/image_data_buffer.cc b/third_party/blink/renderer/platform/graphics/image_data_buffer.cc
index 01593413e3..f868bbe7f7 100644
--- a/third_party/blink/renderer/platform/graphics/image_data_buffer.cc
+++ b/third_party/blink/renderer/platform/graphics/image_data_buffer.cc
@@ -32,8 +32,11 @@
 
 #include "third_party/blink/renderer/platform/graphics/image_data_buffer.h"
 
+#include "base/command_line.h"
 #include "base/compiler_specific.h"
 #include "base/memory/ptr_util.h"
+#include "components/ungoogled/ungoogled_switches.h"
+#include "third_party/blink/renderer/platform/graphics/static_bitmap_image.h"
 #include "third_party/blink/renderer/platform/image-encoders/image_encoder_utils.h"
 #include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 #include "third_party/blink/renderer/platform/wtf/text/base64.h"
@@ -131,6 +134,11 @@ base::span<const uint8_t> ImageDataBuffer::PixelData() const {
 bool ImageDataBuffer::EncodeImage(const ImageEncodingMimeType mime_type,
                                   const double& quality,
                                   Vector<unsigned char>* encoded_image) const {
+  const base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(switches::kFingerprint)) {
+    // shuffle subchannel color data within the pixmap
+    StaticBitmapImage::ShuffleSubchannelColorData(pixmap_.writable_addr(), pixmap_.info(), 0, 0);
+  }
   return ImageEncoder::Encode(encoded_image, pixmap_, mime_type, quality);
 }
 
diff --git a/third_party/blink/renderer/platform/graphics/static_bitmap_image.cc b/third_party/blink/renderer/platform/graphics/static_bitmap_image.cc
index db103dba87..54d8ae81b8 100644
--- a/third_party/blink/renderer/platform/graphics/static_bitmap_image.cc
+++ b/third_party/blink/renderer/platform/graphics/static_bitmap_image.cc
@@ -4,9 +4,12 @@
 
 #include "third_party/blink/renderer/platform/graphics/static_bitmap_image.h"
 
+#include <vector>
+#include "base/command_line.h"
 #include "base/rand_util.h"
 #include "base/logging.h"
 #include "base/numerics/checked_math.h"
+#include "components/ungoogled/ungoogled_switches.h"
 #include "gpu/command_buffer/client/gles2_interface.h"
 #include "third_party/blink/renderer/platform/graphics/accelerated_static_bitmap_image.h"
 #include "third_party/blink/renderer/platform/graphics/graphics_context.h"
@@ -131,15 +134,10 @@ void StaticBitmapImage::ShuffleSubchannelColorData(const void *addr, const SkIma
     return;
   }
 
-  // generate the first random number here
-  double shuffleX = base::RandDouble();
-
-  // cap maximum pixels to change
-  auto pixels = (w + h) / 128;
-  if (pixels > 10) {
-    pixels = 10;
-  } else if (pixels < 2) {
-    pixels = 2;
+  std::string seed_str = "0";
+  const base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(switches::kFingerprint)) {
+      seed_str = command_line->GetSwitchValueASCII(switches::kFingerprint);
   }
 
   auto colorType = info.colorType();
@@ -147,120 +145,249 @@ void StaticBitmapImage::ShuffleSubchannelColorData(const void *addr, const SkIma
 
   DLOG(INFO) << "BRM: ShuffleSubchannelColorData() w=" << w << " h=" << h << " colorType=" << colorType << " fRowBytes=" << fRowBytes;
 
-  // second random number (for y/height)
-  double shuffleY = base::RandDouble();
-
-  // calculate random coordinates using bisection
-  auto currentW = w, currentH = h;
-  for(;pixels >= 0; pixels--) {
-    int x = currentW * shuffleX, y = currentH * shuffleY;
-
-    // calculate randomisation amounts for each RGB component
-    uint8_t shuffleR = base::RandInt(0, 4);
-    uint8_t shuffleG = (shuffleR + x) % 4;
-    uint8_t shuffleB = (shuffleG + y) % 4;
-
-    // manipulate pixel data to slightly change the R, G, B components
-    switch (colorType) {
-      case kAlpha_8_SkColorType:
-      {
-         auto *pixel = writable_addr(uint8_t, addr, fRowBytes, x, y);
-         auto r = SkColorGetR(*pixel), g = SkColorGetG(*pixel), b = SkColorGetB(*pixel), a = SkColorGetA(*pixel);
-
-         r = shuffleComponent(r, UINT8_MAX-1, shuffleR);
-         g = shuffleComponent(g, UINT8_MAX-1, shuffleG);
-         b = shuffleComponent(b, UINT8_MAX-1, shuffleB);
-         // alpha is left unchanged
+  auto max_pixels = (w * h) / 128;
+  if (max_pixels > 10) {
+    max_pixels = 10;
+  } else if (max_pixels < 2) {
+    max_pixels = 2;
+  }
 
-         *pixel = SkColorSetARGB(a, r, g, b);
-      }
-      break;
-      case kGray_8_SkColorType:
-      {
-         auto *pixel = writable_addr(uint8_t, addr, fRowBytes, x, y);
-         *pixel = shuffleComponent(*pixel, UINT8_MAX-1, shuffleB);
+  int modified_pixels = 0;
+
+  // 扫描所有像素，找出边缘像素并直接处理
+  for (int y = 0; y < h - 1 && modified_pixels < max_pixels; y++) {  // 排除最后一行
+    for (int x = 0; x < w - 1 && modified_pixels < max_pixels; x++) {  // 排除最后一列
+      bool isEdge = false;
+      bool isValidColor = false;
+
+      // 检查当前像素是否为边缘像素，并且不是纯黑或纯白
+      switch (colorType) {
+        case kRGBA_8888_SkColorType:
+        {
+          auto *current = writable_addr(uint32_t, addr, fRowBytes, x, y);
+          auto *right = writable_addr(uint32_t, addr, fRowBytes, x + 1, y);
+          auto *bottom = writable_addr(uint32_t, addr, fRowBytes, x, y + 1);
+
+          auto r = SkGetPackedR32(*current);
+          auto g = SkGetPackedG32(*current);
+          auto b = SkGetPackedB32(*current);
+
+          // 检查是否不是纯黑或纯白
+          isValidColor = !((r == 0 && g == 0 && b == 0) || (r == 255 && g == 255 && b == 255));
+
+          // 检查是否为边缘（与右侧或下侧像素不同）
+          if (isValidColor) {
+            isEdge = (*current != *right) || (*current != *bottom);
+          }
+
+          if (isEdge && isValidColor) {
+            // 直接处理这个像素
+            std::string pixel_key_base = seed_str + "_x" + std::to_string(x) + "_y" + std::to_string(y);
+            std::string pixel_key_r = pixel_key_base + "_r";
+            std::string pixel_key_g = pixel_key_base + "_g";
+            std::string pixel_key_b = pixel_key_base + "_b";
+
+            uint8_t shuffleR = std::hash<std::string>{}(pixel_key_r) & 1;
+            uint8_t shuffleG = std::hash<std::string>{}(pixel_key_g) & 1;
+            uint8_t shuffleB = std::hash<std::string>{}(pixel_key_b) & 1;
+
+            auto a = SkGetPackedA32(*current);
+            r = (r & ~0x1) | shuffleR;
+            g = (g & ~0x1) | shuffleG;
+            b = (b & ~0x1) | shuffleB;
+
+            *current = (a << SK_A32_SHIFT) | (r << SK_R32_SHIFT) |
+                      (g << SK_G32_SHIFT) | (b << SK_B32_SHIFT);
+            modified_pixels++;
+          }
+        }
+        break;
+
+        case kBGRA_8888_SkColorType:
+        {
+          auto *current = writable_addr(uint32_t, addr, fRowBytes, x, y);
+          auto *right = writable_addr(uint32_t, addr, fRowBytes, x + 1, y);
+          auto *bottom = writable_addr(uint32_t, addr, fRowBytes, x, y + 1);
+
+          auto b = SkGetPackedR32(*current);
+          auto g = SkGetPackedG32(*current);
+          auto r = SkGetPackedB32(*current);
+
+          // 检查是否不是纯黑或纯白
+          isValidColor = !((r == 0 && g == 0 && b == 0) || (r == 255 && g == 255 && b == 255));
+
+          // 检查是否为边缘（与右侧或下侧像素不同）
+          if (isValidColor) {
+            isEdge = (*current != *right) || (*current != *bottom);
+          }
+
+          if (isEdge && isValidColor) {
+            // 直接处理这个像素
+            std::string pixel_key_base = seed_str + "_x" + std::to_string(x) + "_y" + std::to_string(y);
+            std::string pixel_key_r = pixel_key_base + "_r";
+            std::string pixel_key_g = pixel_key_base + "_g";
+            std::string pixel_key_b = pixel_key_base + "_b";
+
+            uint8_t shuffleR = std::hash<std::string>{}(pixel_key_r) & 1;
+            uint8_t shuffleG = std::hash<std::string>{}(pixel_key_g) & 1;
+            uint8_t shuffleB = std::hash<std::string>{}(pixel_key_b) & 1;
+
+            auto a = SkGetPackedA32(*current);
+            r = (r & ~0x1) | shuffleR;
+            g = (g & ~0x1) | shuffleG;
+            b = (b & ~0x1) | shuffleB;
+
+            *current = (a << SK_BGRA_A32_SHIFT) | (r << SK_BGRA_R32_SHIFT) |
+                      (g << SK_BGRA_G32_SHIFT) | (b << SK_BGRA_B32_SHIFT);
+            modified_pixels++;
+          }
+        }
+        break;
+
+        case kGray_8_SkColorType:
+        {
+          auto *current = writable_addr(uint8_t, addr, fRowBytes, x, y);
+          auto *right = writable_addr(uint8_t, addr, fRowBytes, x + 1, y);
+          auto *bottom = writable_addr(uint8_t, addr, fRowBytes, x, y + 1);
+
+          isValidColor = (*current != 0 && *current != 255);
+          if (isValidColor) {
+            isEdge = (*current != *right) || (*current != *bottom);
+          }
+
+          if (isEdge && isValidColor) {
+            // 直接处理这个像素
+            std::string pixel_key_base = seed_str + "_x" + std::to_string(x) + "_y" + std::to_string(y);
+            std::string pixel_key_b = pixel_key_base + "_b";
+            uint8_t shuffleB = std::hash<std::string>{}(pixel_key_b) & 1;
+            *current = (*current & ~0x1) | shuffleB;
+            modified_pixels++;
+          }
+        }
+        break;
+
+        case kRGB_565_SkColorType:
+        {
+          auto *current = writable_addr(uint16_t, addr, fRowBytes, x, y);
+          auto *right = writable_addr(uint16_t, addr, fRowBytes, x + 1, y);
+          auto *bottom = writable_addr(uint16_t, addr, fRowBytes, x, y + 1);
+
+          unsigned r = SkPacked16ToR32(*current);
+          unsigned g = SkPacked16ToG32(*current);
+          unsigned b = SkPacked16ToB32(*current);
+
+          isValidColor = !((r == 0 && g == 0 && b == 0) || (r == 31 && g == 63 && b == 31));
+          if (isValidColor) {
+            isEdge = (*current != *right) || (*current != *bottom);
+          }
+
+          if (isEdge && isValidColor) {
+            // 直接处理这个像素
+            std::string pixel_key_base = seed_str + "_x" + std::to_string(x) + "_y" + std::to_string(y);
+            std::string pixel_key_r = pixel_key_base + "_r";
+            std::string pixel_key_g = pixel_key_base + "_g";
+            std::string pixel_key_b = pixel_key_base + "_b";
+
+            uint8_t shuffleR = std::hash<std::string>{}(pixel_key_r) & 1;
+            uint8_t shuffleG = std::hash<std::string>{}(pixel_key_g) & 1;
+            uint8_t shuffleB = std::hash<std::string>{}(pixel_key_b) & 1;
+
+            r = (r & ~0x1) | (shuffleR & 0x1);
+            g = (g & ~0x1) | (shuffleG & 0x1);
+            b = (b & ~0x1) | (shuffleB & 0x1);
+
+            unsigned r16 = (r & SK_R16_MASK) << SK_R16_SHIFT;
+            unsigned g16 = (g & SK_G16_MASK) << SK_G16_SHIFT;
+            unsigned b16 = (b & SK_B16_MASK) << SK_B16_SHIFT;
+
+            *current = r16 | g16 | b16;
+            modified_pixels++;
+          }
+        }
+        break;
+
+        case kARGB_4444_SkColorType:
+        {
+          auto *current = writable_addr(uint16_t, addr, fRowBytes, x, y);
+          auto *right = writable_addr(uint16_t, addr, fRowBytes, x + 1, y);
+          auto *bottom = writable_addr(uint16_t, addr, fRowBytes, x, y + 1);
+
+          auto r = SkGetPackedR4444(*current);
+          auto g = SkGetPackedG4444(*current);
+          auto b = SkGetPackedB4444(*current);
+
+          isValidColor = !((r == 0 && g == 0 && b == 0) || (r == 15 && g == 15 && b == 15));
+          if (isValidColor) {
+            isEdge = (*current != *right) || (*current != *bottom);
+          }
+
+          if (isEdge && isValidColor) {
+            // 直接处理这个像素
+            std::string pixel_key_base = seed_str + "_x" + std::to_string(x) + "_y" + std::to_string(y);
+            std::string pixel_key_r = pixel_key_base + "_r";
+            std::string pixel_key_g = pixel_key_base + "_g";
+            std::string pixel_key_b = pixel_key_base + "_b";
+
+            uint8_t shuffleR = std::hash<std::string>{}(pixel_key_r) & 1;
+            uint8_t shuffleG = std::hash<std::string>{}(pixel_key_g) & 1;
+            uint8_t shuffleB = std::hash<std::string>{}(pixel_key_b) & 1;
+
+            auto a = SkGetPackedA4444(*current);
+            r = (r & ~0x1) | (shuffleR & 0x1);
+            g = (g & ~0x1) | (shuffleG & 0x1);
+            b = (b & ~0x1) | (shuffleB & 0x1);
+
+            unsigned a4 = (a & 0xF) << SK_A4444_SHIFT;
+            unsigned r4 = (r & 0xF) << SK_R4444_SHIFT;
+            unsigned g4 = (g & 0xF) << SK_G4444_SHIFT;
+            unsigned b4 = (b & 0xF) << SK_B4444_SHIFT;
+
+            *current = r4 | b4 | g4 | a4;
+            modified_pixels++;
+          }
+        }
+        break;
+
+        case kAlpha_8_SkColorType:
+        {
+          auto *current = writable_addr(uint8_t, addr, fRowBytes, x, y);
+          auto *right = writable_addr(uint8_t, addr, fRowBytes, x + 1, y);
+          auto *bottom = writable_addr(uint8_t, addr, fRowBytes, x, y + 1);
+
+          auto r = SkColorGetR(*current);
+          auto g = SkColorGetG(*current);
+          auto b = SkColorGetB(*current);
+
+          isValidColor = !((r == 0 && g == 0 && b == 0) || (r == 255 && g == 255 && b == 255));
+          if (isValidColor) {
+            isEdge = (*current != *right) || (*current != *bottom);
+          }
+
+          if (isEdge && isValidColor) {
+            // 直接处理这个像素
+            std::string pixel_key_base = seed_str + "_x" + std::to_string(x) + "_y" + std::to_string(y);
+            std::string pixel_key_r = pixel_key_base + "_r";
+            std::string pixel_key_g = pixel_key_base + "_g";
+            std::string pixel_key_b = pixel_key_base + "_b";
+
+            uint8_t shuffleR = std::hash<std::string>{}(pixel_key_r) & 1;
+            uint8_t shuffleG = std::hash<std::string>{}(pixel_key_g) & 1;
+            uint8_t shuffleB = std::hash<std::string>{}(pixel_key_b) & 1;
+
+            auto a = SkColorGetA(*current);
+            r = (r & ~0x1) | shuffleR;
+            g = (g & ~0x1) | shuffleG;
+            b = (b & ~0x1) | shuffleB;
+
+            *current = SkColorSetARGB(a, r, g, b);
+            modified_pixels++;
+          }
+        }
+        break;
+
+        default:
+          break;
       }
-      break;
-      case kRGB_565_SkColorType:
-      {
-         auto *pixel = writable_addr(uint16_t, addr, fRowBytes, x, y);
-         unsigned    r = SkPacked16ToR32(*pixel);
-         unsigned    g = SkPacked16ToG32(*pixel);
-         unsigned    b = SkPacked16ToB32(*pixel);
-
-         r = shuffleComponent(r, 31, shuffleR);
-         g = shuffleComponent(g, 63, shuffleG);
-         b = shuffleComponent(b, 31, shuffleB);
-
-         unsigned r16 = (r & SK_R16_MASK) << SK_R16_SHIFT;
-         unsigned g16 = (g & SK_G16_MASK) << SK_G16_SHIFT;
-         unsigned b16 = (b & SK_B16_MASK) << SK_B16_SHIFT;
-
-         *pixel = r16 | g16 | b16;
-      }
-      break;
-      case kARGB_4444_SkColorType:
-      {
-         auto *pixel = writable_addr(uint16_t, addr, fRowBytes, x, y);
-         auto a = SkGetPackedA4444(*pixel), r = SkGetPackedR4444(*pixel), g = SkGetPackedG4444(*pixel), b = SkGetPackedB4444(*pixel);
-
-         r = shuffleComponent(r, 15, shuffleR);
-         g = shuffleComponent(g, 15, shuffleG);
-         b = shuffleComponent(b, 15, shuffleB);
-         // alpha is left unchanged
-
-         unsigned a4 = (a & 0xF) << SK_A4444_SHIFT;
-         unsigned r4 = (r & 0xF) << SK_R4444_SHIFT;
-         unsigned g4 = (g & 0xF) << SK_G4444_SHIFT;
-         unsigned b4 = (b & 0xF) << SK_B4444_SHIFT;
-
-         *pixel = r4 | b4 | g4 | a4;
-      }
-      break;
-      case kRGBA_8888_SkColorType:
-      {
-         auto *pixel = writable_addr(uint32_t, addr, fRowBytes, x, y);
-         auto a = SkGetPackedA32(*pixel), r = SkGetPackedR32(*pixel), g = SkGetPackedG32(*pixel), b = SkGetPackedB32(*pixel);
-
-         r = shuffleComponent(r, UINT8_MAX-1, shuffleR);
-         g = shuffleComponent(g, UINT8_MAX-1, shuffleG);
-         b = shuffleComponent(b, UINT8_MAX-1, shuffleB);
-         // alpha is left unchanged
-
-         *pixel = (a << SK_A32_SHIFT) | (r << SK_R32_SHIFT) |
-                  (g << SK_G32_SHIFT) | (b << SK_B32_SHIFT);
-      }
-      break;
-      case kBGRA_8888_SkColorType:
-      {
-         auto *pixel = writable_addr(uint32_t, addr, fRowBytes, x, y);
-         auto a = SkGetPackedA32(*pixel), b = SkGetPackedR32(*pixel), g = SkGetPackedG32(*pixel), r = SkGetPackedB32(*pixel);
-
-         r = shuffleComponent(r, UINT8_MAX-1, shuffleR);
-         g = shuffleComponent(g, UINT8_MAX-1, shuffleG);
-         b = shuffleComponent(b, UINT8_MAX-1, shuffleB);
-         // alpha is left unchanged
-
-         *pixel = (a << SK_BGRA_A32_SHIFT) | (r << SK_BGRA_R32_SHIFT) |
-                  (g << SK_BGRA_G32_SHIFT) | (b << SK_BGRA_B32_SHIFT);
-      }
-      break;
-      default:
-         // the remaining formats are not expected to be used in Chromium
-         LOG(WARNING) << "BRM: ShuffleSubchannelColorData(): Ignoring pixel format";
-         return;
-    }
-
-    // keep bisecting or reset current width/height as needed
-    if (x == 0) {
-       currentW = w;
-    } else {
-       currentW = x;
-    }
-    if (y == 0) {
-       currentH = h;
-    } else {
-       currentH = y;
     }
   }
 }
-- 
2.43.0

