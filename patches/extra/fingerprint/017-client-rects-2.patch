diff --git a/third_party/blink/renderer/core/dom/document.cc b/third_party/blink/renderer/core/dom/document.cc
index 76c494dfd2..b90c977aae 100644
--- a/third_party/blink/renderer/core/dom/document.cc
+++ b/third_party/blink/renderer/core/dom/document.cc
@@ -876,8 +876,8 @@ Document::Document(const DocumentInit& initializer,
   if (command_line->HasSwitch(switches::kFingerprint)) {
     std::string seed_str = command_line->GetSwitchValueASCII(switches::kFingerprint);
     // 为x和y使用不同的组合字符串
-    std::string combined_x = seed_str + "canvas_noise_x";
-    std::string combined_y = seed_str + "canvas_noise_y";
+    std::string combined_x = seed_str + "offset_x";
+    std::string combined_y = seed_str + "offset_y";
 
     uint32_t hash_val_x = std::hash<std::string>{}(combined_x);
     uint32_t hash_val_y = std::hash<std::string>{}(combined_y);
@@ -886,9 +886,9 @@ Document::Document(const DocumentInit& initializer,
     double norm_x = (hash_val_x & 0xFFFFFFFF) / 4294967295.0 - 0.5;
     double norm_y = (hash_val_y & 0xFFFFFFFF) / 4294967295.0 - 0.5;
 
-    // 计算噪声因子
-    noise_factor_x_ = 1.0 + norm_x * 0.000003;
-    noise_factor_y_ = 1.0 + norm_y * 0.000003;
+    // 计算很小的偏移量：±0.001像素
+    noise_factor_x_ = norm_x * 0.002;
+    noise_factor_y_ = norm_y * 0.002;
   }
   if (base::FeatureList::IsEnabled(features::kDelayAsyncScriptExecution) &&
       features::kDelayAsyncScriptExecutionDelayByDefaultParam.Get()) {
diff --git a/third_party/blink/renderer/core/dom/element.cc b/third_party/blink/renderer/core/dom/element.cc
index ea51bb5e04..9751e36b03 100644
--- a/third_party/blink/renderer/core/dom/element.cc
+++ b/third_party/blink/renderer/core/dom/element.cc
@@ -2822,6 +2822,28 @@ void Element::ClientQuads(Vector<gfx::QuadF>& quads) const {
   }
 }
 
+bool Element::ShouldSkipClientRectsOffset() const {
+  if (!GetLayoutObject() || !GetLayoutObject()->Style()) {
+    return false;
+  }
+
+  const ComputedStyle& style = *GetLayoutObject()->Style();
+
+  // 检查是否为绝对定位
+  if (style.GetPosition() != EPosition::kAbsolute) {
+    return false;
+  }
+
+  // 检查top和left是否都是"确定的"值（Zero或Fixed）
+  const Length& top = style.Top();
+  const Length& left = style.Left();
+
+  bool top_is_deterministic = top.IsZero() || top.IsFixed();
+  bool left_is_deterministic = left.IsZero() || left.IsFixed();
+
+  return (top_is_deterministic && left_is_deterministic);
+}
+
 DOMRectList* Element::getClientRects() {
   // TODO(crbug.com/1499981): This should be removed once synchronized scrolling
   // impact is understood.
@@ -2840,8 +2862,10 @@ DOMRectList* Element::getClientRects() {
                                                     *element_layout_object);
   const base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
   if (command_line->HasSwitch(switches::kFingerprint)) {
-    for (gfx::QuadF& quad : quads) {
-      quad.Scale(GetDocument().GetNoiseFactorX(), GetDocument().GetNoiseFactorY());
+    if (!ShouldSkipClientRectsOffset()) {
+      for (gfx::QuadF& quad : quads) {
+        quad.Offset(GetDocument().GetNoiseFactorX(), GetDocument().GetNoiseFactorY());
+      }
     }
   }
   return MakeGarbageCollected<DOMRectList>(quads);
@@ -2873,7 +2897,9 @@ gfx::RectF Element::GetBoundingClientRectNoLifecycleUpdate() const {
                                                    *element_layout_object);
   const base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
   if (command_line->HasSwitch(switches::kFingerprint)) {
-    result.Scale(GetDocument().GetNoiseFactorX(), GetDocument().GetNoiseFactorY());
+    if (!ShouldSkipClientRectsOffset()) {
+      result.Offset(GetDocument().GetNoiseFactorX(), GetDocument().GetNoiseFactorY());
+    }
   }
   return result;
 }
diff --git a/third_party/blink/renderer/core/dom/element.h b/third_party/blink/renderer/core/dom/element.h
index 2efec95027..626fa11abc 100644
--- a/third_party/blink/renderer/core/dom/element.h
+++ b/third_party/blink/renderer/core/dom/element.h
@@ -530,6 +530,8 @@ class CORE_EXPORT Element : public ContainerNode, public Animatable {
   // does not (yet) apply (overflow) element clipping (crbug.com/889840).
   gfx::Rect VisibleBoundsInLocalRoot() const;
 
+  bool ShouldSkipClientRectsOffset() const;
+
   DOMRectList* getClientRects();
   // Returns a rectangle in zoomed pixel units.
   gfx::RectF GetBoundingClientRectNoLifecycleUpdateNoAdjustment() const;
diff --git a/third_party/blink/renderer/core/dom/range.cc b/third_party/blink/renderer/core/dom/range.cc
index 1721d6e922..9baf9245aa 100644
--- a/third_party/blink/renderer/core/dom/range.cc
+++ b/third_party/blink/renderer/core/dom/range.cc
@@ -1639,7 +1639,7 @@ DOMRectList* Range::getClientRects() const {
   const base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
   if (command_line->HasSwitch(switches::kFingerprint)) {
     for (gfx::QuadF& quad : quads) {
-      quad.Scale(owner_document_->GetNoiseFactorX(), owner_document_->GetNoiseFactorY());
+      quad.Offset(owner_document_->GetNoiseFactorX(), owner_document_->GetNoiseFactorY());
     }
   }
 
@@ -1653,7 +1653,7 @@ DOMRect* Range::getBoundingClientRect() const {
   auto rect = BoundingRect();
   const base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
   if (command_line->HasSwitch(switches::kFingerprint)) {
-    rect.Scale(owner_document_->GetNoiseFactorX(), owner_document_->GetNoiseFactorY());
+    rect.Offset(owner_document_->GetNoiseFactorX(), owner_document_->GetNoiseFactorY());
   }
   return DOMRect::FromRectF(rect);
 }
diff --git a/ui/gfx/geometry/quad_f.cc b/ui/gfx/geometry/quad_f.cc
index b6306c2cc5..da400b46f5 100644
--- a/ui/gfx/geometry/quad_f.cc
+++ b/ui/gfx/geometry/quad_f.cc
@@ -137,6 +137,22 @@ void QuadF::Scale(float x_scale, float y_scale) {
   p4_.Scale(x_scale, y_scale);
 }
 
+void QuadF::Offset(float x_offset, float y_offset) {
+  // 计算轴对齐边界框的宽高
+  const auto [min, max] = Extents();
+  float width = max.x() - min.x();
+  float height = max.y() - min.y();
+
+  if (WithinEpsilon(width, 0.0f) || WithinEpsilon(height, 0.0f)) {
+    return;
+  }
+
+  p1_.Offset(x_offset, y_offset);
+  p2_.Offset(x_offset, y_offset);
+  p3_.Offset(x_offset, y_offset);
+  p4_.Offset(x_offset, y_offset);
+}
+
 void QuadF::operator+=(const Vector2dF& rhs) {
   p1_ += rhs;
   p2_ += rhs;
diff --git a/ui/gfx/geometry/quad_f.h b/ui/gfx/geometry/quad_f.h
index 6c3d299edb..6c3885cf6d 100644
--- a/ui/gfx/geometry/quad_f.h
+++ b/ui/gfx/geometry/quad_f.h
@@ -106,6 +106,11 @@ class COMPONENT_EXPORT(GEOMETRY) QuadF {
   // Scale each point in the quad by the scale factors along each axis.
   void Scale(float x_scale, float y_scale);
 
+  // Offset each point in the quad by the offset values.
+  void Offset(float offset) { Offset(offset, offset); }
+  // Offset each point in the quad by the offset values along each axis.
+  void Offset(float x_offset, float y_offset);
+
   // Tests whether any part of the rectangle intersects with this quad.
   // This only works for convex quads.
   // This intersection is edge-inclusive and will return true even if the
